<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>색상 감정 일기 - EmotiCare</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        .journal-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            background: white;
            padding: 1.5rem;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }
        
        .month-nav {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .month-nav button {
            background: #667eea;
            color: white;
            border: none;
            padding: 0.5rem;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .month-nav button:hover {
            background: #764ba2;
            transform: scale(1.1);
        }
        
        .current-month {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
        }
        
        .emotion-legend {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .emotion-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }
        
        .emotion-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .calendar {
            background: white;
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background: #e1e8ed;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .calendar-day-header {
            background: #667eea;
            color: white;
            padding: 1rem;
            text-align: center;
            font-weight: 600;
        }
        
        .calendar-day {
            background: white;
            padding: 0.5rem; /* 패딩 약간 줄임 */
            min-height: 100px; /* 최소 높이 조정 */
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* 위에서부터 정렬 */
        }
        
        .calendar-day:hover {
            background: #f8f9ff;
        }
        
        .calendar-day.other-month {
            color: #ccc;
            background: #f8f9fa;
        }
        
        .calendar-day.today {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .calendar-day.has-emotion {
            border: 3px solid;
        }
        
        .day-number {
            font-weight: 600;
            margin-bottom: 0.3rem; /* 날짜와 메모 사이 간격 */
            z-index: 2; /* 스티커보다 위에 오도록 */
            position: relative; /* z-index 적용 위해 */
        }
        
        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }
        
        .stats-card {
            background: white;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }
        
        .stats-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #333;
        }
        
        .emotion-stats {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .emotion-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .emotion-bar {
            flex: 1;
            height: 10px;
            background: #e1e8ed;
            border-radius: 5px;
            margin: 0 1rem;
            overflow: hidden;
        }
        
        .emotion-bar-fill {
            height: 100%;
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        .prescription-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 2rem;
            border-radius: 15px;
            text-align: center;
        }
        
        .prescription-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        .prescription-text {
            font-size: 1.1rem;
            line-height: 1.6;
        }

        /* 감정 강도 슬라이더 레이블 정렬 개선 */
        .intensity-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #666;
            margin-top: 0.25rem;
            width: 90%; /* 슬라이더 트랙보다 약간 좁게 */
            margin-left: auto; /* 중앙 정렬 */
            margin-right: auto; /* 중앙 정렬 */
        }
        .intensity-labels span {
             /* 필요시 개별 숫자 위치 조정 */
        }

        .modal-action-buttons {
            display: flex;
            gap: 1rem; /* 버튼 사이 간격 */
        }
        .modal-action-buttons button {
            flex: 1; /* 버튼들이 공간을 균등하게 차지하도록 함 */
            width: auto; /* styles.css의 .form-group .btn-primary width: 100% 오버라이드 */
            padding: 0.8rem 1rem; /* 버튼 패딩 일관성 있게 조정 */
            justify-content: center; /* 버튼 내부 텍스트 수평 중앙 정렬 (버튼은 inline-flex) */
            /* font-size: 0.9rem; /* 필요시 폰트 크기 조정 */
        }

        /* 달력 감정 표시 (스티커 형태) */
        .emotion-indicator {
            width: 18px; /* 스티커 크기 */
            height: 18px; /* 스티커 크기 */
            border-radius: 50%; /* 원형 */
            position: absolute; /* 절대 위치 */
            bottom: 5px; /* 하단에서 5px */
            right: 5px; /* 우측에서 5px */
            border: 2px solid white; /* 흰색 테두리 */
            box-shadow: 0 1px 3px rgba(0,0,0,0.2); /* 그림자 */
            z-index: 1; /* 다른 요소 위에 표시 */
        }

        /* 달력 메모 미리보기 */
        .emotion-note-preview {
            font-size: 0.75rem; /* 작은 폰트 */
            color: #555; /* 텍스트 색상 */
            margin-top: 0.2rem;
            line-height: 1.3;
            max-height: 2.6em; /* 최대 높이 (약 2줄) */
            overflow: hidden; /* 넘치는 텍스트 숨김 */
            text-overflow: ellipsis; /* 넘치는 텍스트에 ... 표시 */
            word-break: break-all; /* 긴 단어 줄바꿈 */
            z-index: 2; /* 스티커보다 위에 오도록 */
            position: relative; /* z-index 적용 위해 */
        }
    </style>
</head>
<body>
    <div id="header-container"></div>
    
    <main>
        <section class="page-header">
            <div class="container">
                <h1 class="page-title">색상 감정 일기</h1>
                <p class="page-subtitle">매일의 감정을 색상으로 기록하고 나만의 패턴을 발견해보세요</p>
            </div>
        </section>
        
        <section class="page-content">
            <div class="journal-container">
                <div class="calendar-header">
                    <div class="month-nav">
                        <button onclick="changeMonth(-1)"><i class="fas fa-chevron-left"></i></button>
                        <span class="current-month" id="currentMonth"></span>
                        <button onclick="changeMonth(1)"><i class="fas fa-chevron-right"></i></button>
                    </div>
                    
                    <div class="emotion-legend">
                        <div class="emotion-item">
                            <div class="emotion-color" style="background: #f39c12;"></div>
                            <span>기쁨</span>
                        </div>
                        <div class="emotion-item">
                            <div class="emotion-color" style="background: #00a693;"></div>
                            <span>평온</span>
                        </div>
                        <div class="emotion-item">
                            <div class="emotion-color" style="background: #8e44ad;"></div>
                            <span>불안</span>
                        </div>
                        <div class="emotion-item">
                            <div class="emotion-color" style="background: #2980b9;"></div>
                            <span>슬픔</span>
                        </div>
                        <div class="emotion-item">
                            <div class="emotion-color" style="background: #c0392b;"></div>
                            <span>화남</span>
                        </div>
                    </div>

                </div>
                
                <div class="calendar">
                    <div class="calendar-grid" id="calendarGrid">
                        <!-- 달력이 여기에 생성됩니다 -->
                    </div>
                </div>
                
                <div class="stats-section">
                    <div class="stats-card">
                        <h3 class="stats-title">이번 달 감정 통계</h3>
                        <div class="emotion-stats" id="emotionStats">
                            <!-- 통계가 여기에 생성됩니다 -->
                        </div>
                    </div>
                    
                    <div class="stats-card">
                        <h3 class="stats-title">마음 처방전</h3>
                        <div class="prescription-card" id="prescriptionCard">
                            <div class="prescription-icon">
                                <i class="fas fa-heart"></i>
                            </div>
                            <div class="prescription-text" id="prescriptionText">
                                감정 데이터를 분석하여 맞춤 처방전을 제공해드립니다.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>
    
    <!-- 감정 기록 모달 -->
    <div id="emotionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalDate">감정 기록</h3>
                <button class="modal-close" onclick="closeEmotionModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>오늘의 감정을 선택해주세요</label>
                    <div class="emotion-selector">
                         <button class="emotion-btn" data-emotion="happy" data-color="#f39c12">
                            <i class="fas fa-laugh"></i>
                            <span>기쁨</span>
                        </button>
                        <button class="emotion-btn" data-emotion="calm" data-color="#00a693">
                            <i class="fas fa-smile"></i>
                            <span>평온</span>
                        </button>
                         <button class="emotion-btn" data-emotion="anxious" data-color="#8e44ad">
                            <i class="fas fa-meh"></i>
                            <span>불안</span>
                        </button>
                        <button class="emotion-btn" data-emotion="sad" data-color="#2980b9">
                            <i class="fas fa-sad-tear"></i>
                            <span>슬픔</span>
                        </button>
                        <button class="emotion-btn" data-emotion="angry" data-color="#c0392b">
                            <i class="fas fa-angry"></i>
                            <span>화남</span>
                        </button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="emotionIntensity">감정 강도 <span style="font-weight:normal; font-size:0.9em;">(1: 약함, 5: 강함)</span></label>
                    <input type="range" id="emotionIntensity" min="1" max="5" value="3" step="1" style="width: 100%;">
                    <div class="intensity-labels">
                        <span>1</span>
                        <span>2</span>
                        <span>3</span>
                        <span>4</span>
                        <span>5</span>
                    </div>
                </div>
                <div class="form-group">
                    <label for="emotionNote">오늘의 기분에 대해 간단히 적어보세요</label>
                    <textarea id="emotionNote" placeholder="오늘 하루는 어떠셨나요?"></textarea>
                </div>
                
                <div class="form-group modal-action-buttons">
                    <button class="btn-primary" onclick="saveEmotion()">저장하기</button>
                    <button class="btn-outline" onclick="deleteEmotion()">삭제하기</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="footer-container"></div>
    
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
    <script src="common.js"></script>
    <script>
        let currentDate = new Date();
        let selectedDate = null;
        let emotionData = {};
        
        const emotions = {
            happy: { name: '기쁨', color: '#f39c12', icon: 'fas fa-laugh' },
            calm: { name: '평온', color: '#00a693', icon: 'fas fa-smile' },
            anxious: { name: '불안', color: '#8e44ad', icon: 'fas fa-meh' },
            sad: { name: '슬픔', color: '#2980b9', icon: 'fas fa-sad-tear' },
            angry: { name: '화남', color: '#c0392b', icon: 'fas fa-angry' }
        };
        
        const prescriptions = {
            // 각 감정별 빈도수에 따른 처방 메시지 (예시: 7단계)
            // maxCount: 해당 메시지가 적용되는 최대 빈도수 (이하)
            happy: [
                { maxCount: 1, message: "기쁨을 조금 더 느껴보세요! 작은 것에서 행복을 찾는 연습은 어때요?" },
                { maxCount: 3, message: "기분 좋은 순간들이 있었네요. 이 기쁨을 주변에 나눠보세요." },
                { maxCount: 5, message: "기쁨을 느끼는 날들이 꽤 있었군요! 긍정적인 마음이 보기 좋아요." },
                { maxCount: 7, message: "행복한 에너지가 느껴지는 달이에요. 이 기운을 잘 유지해보세요!" },
                { maxCount: 9, message: "많은 날들을 기쁘게 보내셨네요! 당신의 밝은 에너지가 주변을 환하게 해요." },
                { maxCount: 11, message: "정말 행복한 한 달이었군요! 이 기쁨을 충분히 누리세요." },
                { maxCount: Infinity, message: "매일매일이 기쁨으로 가득 찬 한 달이었군요! 당신은 행복을 만들어가는 사람입니다." }
            ],
            calm: [
                { maxCount: 1, message: "평온함을 찾아보는 건 어때요? 조용한 명상이나 산책이 도움이 될 수 있어요." },
                { maxCount: 3, message: "마음이 평온했던 순간들이 있었네요. 그 느낌을 기억해보세요." },
                { maxCount: 5, message: "안정적인 마음 상태를 잘 유지하고 있어요. 꾸준한 자기 돌봄 덕분일 거예요." },
                { maxCount: 7, message: "꽤 평온한 한 달을 보내셨네요. 스트레스 관리를 잘 하고 계신 것 같아요." },
                { maxCount: 9, message: "매우 평온한 상태를 유지하고 계시는군요. 내면의 안정감이 큰 강점이에요." },
                { maxCount: 11, message: "대부분의 시간을 평온하게 보내셨네요. 마음의 균형을 잘 잡고 계십니다." },
                { maxCount: Infinity, message: "이번 달 대부분 평온함을 느끼셨군요! 정말 멋진 마음 상태입니다. 이 평화를 계속 유지하세요." }
            ],
            anxious: [
                { maxCount: 0, message: "이번 달에는 불안감을 거의 느끼지 않으셨네요. 안정적인 한 달이었던 것 같습니다." }, // 이 메시지는 dominantEmotion이 anxious가 아닐 때 나올 수 있음
                { maxCount: 2, message: "가끔 불안감을 느꼈군요. 그럴 땐 심호흡이나 좋아하는 활동으로 주의를 돌려보세요." },
                { maxCount: 4, message: "불안한 마음이 조금씩 있었네요. 원인을 파악하고 스스로를 다독여주세요." },
                { maxCount: 6, message: "불안감이 자주 느껴졌다면, 규칙적인 생활과 휴식이 도움이 될 수 있어요." },
                { maxCount: 8, message: "불안함이 꽤 느껴지는 달이었네요. 마음챙김 연습이나 이완 기법을 시도해보세요." },
                { maxCount: 11, message: "지속적인 불안은 에너지를 소모시켜요. 전문가의 도움을 고려해보는 것도 좋아요." },
                { maxCount: Infinity, message: "높은 수준의 불안을 경험하고 계신 것 같습니다. 혼자 힘들어하지 마시고 꼭 전문가와 상담해보세요." }
            ],
            sad: [
                { maxCount: 0, message: "이번 달에는 슬픔을 거의 느끼지 않으셨네요. 밝고 긍정적인 한 달이었던 것 같습니다." },
                { maxCount: 2, message: "가끔 슬픈 감정이 들었군요. 그 감정을 충분히 느끼고 흘려보내는 것이 중요해요." },
                { maxCount: 4, message: "슬픔을 느꼈던 날들이 있었네요. 자신을 위로하고 좋아하는 사람들과 시간을 보내세요." },
                { maxCount: 6, message: "슬픈 감정이 자주 찾아왔다면, 기분 전환을 위한 활동이나 취미를 가져보세요." },
                { maxCount: 8, message: "마음이 아팠던 날들이 꽤 있었네요. 슬픔을 표현하고 도움을 요청해도 괜찮아요." },
                { maxCount: 11, message: "지속적인 슬픔은 우울감으로 이어질 수 있어요. 전문가와 상담하여 마음을 돌보세요." },
                { maxCount: Infinity, message: "깊은 슬픔을 경험하고 계신 것 같습니다. 혼자 감당하기 어렵다면 반드시 전문가의 도움을 받으세요." }
            ],
            angry: [
                { maxCount: 0, message: "이번 달에는 화나는 일이 거의 없으셨네요! 평온한 한 달을 보내신 것 같아요." },
                { maxCount: 2, message: "가끔 화가 났었군요. 그럴 땐 잠시 숨을 고르고 원인을 생각해보세요." },
                { maxCount: 4, message: "화나는 일이 조금 있었네요. 화를 건강하게 표현하는 방법을 찾아보는 건 어때요?" },
                { maxCount: 6, message: "화가 자주 느껴졌다면, 스트레스 요인을 점검하고 해소할 방법을 찾아보세요." },
                { maxCount: 8, message: "화가 꽤 쌓인 것 같아요. 운동이나 명상으로 마음을 다스려보는 것을 고려해보세요." },
                { maxCount: 11, message: "지속적인 화는 마음을 지치게 할 수 있어요. 적극적인 스트레스 관리가 필요해 보여요." },
                { maxCount: Infinity, message: "매우 높은 빈도로 화를 느끼고 계십니다. 감정 조절에 어려움이 있다면 전문가와 상담하여 도움을 받는 것이 좋습니다." }
            ],
            default: "감정을 꾸준히 기록하고 자신을 더 깊이 이해해보세요. 어떤 감정이든 소중한 당신의 일부입니다."
        };
        
        document.addEventListener('DOMContentLoaded', function() {
            loadEmotionData();
            renderCalendar();
            updateStats();
            setupEmotionSelector();
        });
        
        function renderCalendar() {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            
            document.getElementById('currentMonth').textContent = 
                `${year}년 ${month + 1}월`;
            
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const startDate = new Date(firstDay);
            startDate.setDate(startDate.getDate() - firstDay.getDay());
            
            const calendarGrid = document.getElementById('calendarGrid');
            calendarGrid.innerHTML = '';
            
            // 요일 헤더
            const dayHeaders = ['일', '월', '화', '수', '목', '금', '토'];
            dayHeaders.forEach(day => {
                const dayHeader = document.createElement('div');
                dayHeader.className = 'calendar-day-header';
                dayHeader.textContent = day;
                calendarGrid.appendChild(dayHeader);
            });
            
            // 날짜 셀
            const today = new Date();
            for (let i = 0; i < 42; i++) {
                const cellDate = new Date(startDate);
                cellDate.setDate(startDate.getDate() + i);
                
                const dayCell = document.createElement('div');
                dayCell.className = 'calendar-day';
                
                if (cellDate.getMonth() !== month) {
                    dayCell.classList.add('other-month');
                }
                
                if (cellDate.toDateString() === today.toDateString()) {
                    dayCell.classList.add('today');
                }
                
                const dayNumber = document.createElement('div'); // 날짜 번호 먼저 추가
                dayNumber.className = 'day-number';
                dayNumber.textContent = cellDate.getDate();
                dayCell.appendChild(dayNumber);
                
                const dateKey = formatDate(cellDate); 
                const emotionRecord = emotionData[dateKey]; 
                
                if (emotionRecord) {
                    dayCell.classList.add('has-emotion');
                    const baseColor = emotions[emotionRecord.type].color;
                    const intensity = emotionRecord.intensity || 3; 
                    
                    const lightnessMap = [0, 0.7, 0.5, 0.3, 0.1, 0]; 
                    const lightnessFactor = lightnessMap[intensity] !== undefined ? lightnessMap[intensity] : lightnessMap[3]; 
                    const displayColor = lightenHexColor(baseColor, lightnessFactor);
                    
                    dayCell.style.borderColor = displayColor;
                    
                    // 메모 미리보기 추가 (날짜 번호 아래)
                    if (emotionRecord.note) {
                        const notePreview = document.createElement('div');
                        notePreview.className = 'emotion-note-preview';
                        notePreview.textContent = emotionRecord.note.substring(0, 25) + (emotionRecord.note.length > 25 ? '...' : ''); // 글자 수 약간 줄임
                        dayCell.appendChild(notePreview);
                    }

                    const indicator = document.createElement('div'); // 스티커는 가장 나중에 추가 (CSS로 위치 조정)
                    indicator.className = 'emotion-indicator'; 
                    indicator.style.background = displayColor;
                    dayCell.appendChild(indicator);
                }
                
                dayCell.addEventListener('click', () => openEmotionModal(cellDate));
                calendarGrid.appendChild(dayCell);
            }
        }
        
        function changeMonth(direction) {
            currentDate.setMonth(currentDate.getMonth() + direction);
            renderCalendar();
            updateStats();
        }
        
        function openEmotionModal(date) {
            selectedDate = date;
            const dateKey = formatDate(date);
            const emotion = emotionData[dateKey];
            
            document.getElementById('modalDate').textContent = 
                `${date.getFullYear()}년 ${date.getMonth() + 1}월 ${date.getDate()}일`;
            
            // 기존 데이터 로드
            if (emotion) {
                document.querySelector(`.emotion-btn[data-emotion="${emotion.type}"]`).classList.add('selected');
                document.getElementById('emotionNote').value = emotion.note || '';
                document.getElementById('emotionIntensity').value = emotion.intensity || 3; 
            } else {
                document.querySelectorAll('.emotion-btn').forEach(btn => 
                    btn.classList.remove('selected'));
                document.getElementById('emotionNote').value = '';
                document.getElementById('emotionIntensity').value = 3; 
            }
            
            document.getElementById('emotionModal').style.display = 'block';
        }
        
        function closeEmotionModal() {
            document.getElementById('emotionModal').style.display = 'none';
            selectedDate = null;
        }
        
        function setupEmotionSelector() {
            document.querySelectorAll('.emotion-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.emotion-btn').forEach(b => 
                        b.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
        }
        
        async function saveEmotion() {
            if (!selectedDate) return;
            
            const selectedBtn = document.querySelector('.emotion-btn.selected');
            if (!selectedBtn) {
                showMessage('감정을 선택해주세요.', 'error');
                return;
            }
            
            const emotionType = selectedBtn.dataset.emotion;
            const note = document.getElementById('emotionNote').value;
            const intensity = parseInt(document.getElementById('emotionIntensity').value, 10); 
            const dateKey = formatDate(selectedDate);
            
            const emotionRecord = {
                type: emotionType,
                note: note,
                date: dateKey,
                intensity: intensity, 
                timestamp: new Date().toISOString()
            };
            
            emotionData[dateKey] = emotionRecord;
            saveToLocalStorage('emotionData', emotionData);
            
            if (currentUser) {
                await saveToFirestore('emotions', dateKey, emotionRecord);
            }
            
            closeEmotionModal();
            renderCalendar();
            updateStats();
            showMessage('감정이 기록되었습니다.', 'success');
        }
        
        async function deleteEmotion() {
            if (!selectedDate) return;
            
            const dateKey = formatDate(selectedDate);
            delete emotionData[dateKey];
            saveToLocalStorage('emotionData', emotionData);
            
            if (currentUser) {
                try {
                    await db.collection('emotions').doc(dateKey).delete();
                } catch (error) {
                    console.error('Firebase 삭제 실패:', error);
                }
            }
            
            closeEmotionModal();
            renderCalendar();
            updateStats();
            showMessage('감정 기록이 삭제되었습니다.', 'success');
        }
        
        function updateStats() {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            
            const monthData = Object.values(emotionData).filter(emotion => {
                const emotionDate = new Date(emotion.date);
                return emotionDate.getFullYear() === year && 
                       emotionDate.getMonth() === month;
            });
            
            const emotionCounts = {};
            Object.keys(emotions).forEach(key => {
                emotionCounts[key] = 0;
            });
            
            monthData.forEach(emotion => {
                if (emotions[emotion.type]) { // 유효한 감정 타입인지 확인
                    emotionCounts[emotion.type]++;
                }
            });
            
            const total = monthData.length;
            const statsContainer = document.getElementById('emotionStats');
            statsContainer.innerHTML = '';
            
            Object.entries(emotionCounts).forEach(([type, count]) => {
                const percentage = total > 0 ? (count / total) * 100 : 0;
                
                const statDiv = document.createElement('div');
                statDiv.className = 'emotion-stat';
                statDiv.innerHTML = `
                    <span>${emotions[type].name}</span>
                    <div class="emotion-bar">
                        <div class="emotion-bar-fill" 
                             style="width: ${percentage}%; background: ${emotions[type].color};">
                        </div>
                    </div>
                    <span>${count}회</span>
                `;
                statsContainer.appendChild(statDiv);
            });
            
            updatePrescription(emotionCounts, total);
        }
        
        // 감정 통계에 따른 처방전 업데이트
        function updatePrescription(emotionCounts, total) {
            if (total === 0) {
                document.getElementById('prescriptionText').textContent = 
                    '감정을 기록하시면 맞춤 처방전을 제공해드립니다.';
                console.log("처방전: 감정 기록 없음");
                return;
            }
            
            // 가장 많이 나타난 감정 찾기
            let dominantEmotionType = null;
            let maxCount = -1; // 0회인 감정도 있으므로 -1로 시작

            for (const [type, count] of Object.entries(emotionCounts)) {
                // 유효한 감정 타입인지 다시 한번 확인
                if (emotions[type] && count > maxCount) {
                    maxCount = count;
                    dominantEmotionType = type;
                }
            }
            
            let prescriptionMessage = prescriptions.default; // 기본 처방전

            if (dominantEmotionType && prescriptions[dominantEmotionType]) {
                const countOfDominantEmotion = emotionCounts[dominantEmotionType];
                const prescriptionLevels = prescriptions[dominantEmotionType];
                
                // 해당 빈도수에 맞는 처방 메시지 찾기
                for (const level of prescriptionLevels) {
                    if (countOfDominantEmotion <= level.maxCount) {
                        prescriptionMessage = level.message; // 올바른 메시지(문자열) 할당
                        break; // 해당 레벨 찾으면 반복 중단
                    }
                }
            } else {
                 // dominantEmotionType이 없거나 해당 감정에 대한 처방전 정의가 없을 경우
                 console.warn("처방전: 지배적인 감정을 찾을 수 없거나 처방전 정의가 없습니다. 기본 메시지를 사용합니다.", { dominantEmotionType, emotionCounts });
            }

            const prescriptionTextElement = document.getElementById('prescriptionText');

            // 최종 메시지가 문자열인지 확인 후 표시
            if (typeof prescriptionMessage === 'string') {
                prescriptionTextElement.textContent = prescriptionMessage;
                console.log("처방전 업데이트 완료:", prescriptionMessage);
            } else {
                // 예상치 못한 값이 할당되었을 경우 오류 처리
                console.error("처방전 업데이트 오류: 최종 메시지 형식이 올바르지 않습니다.", prescriptionMessage);
                prescriptionTextElement.textContent = "처방전 로드 오류: 메시지 형식이 올바르지 않습니다.";
            }
        }
        
        // 로컬 스토리지 및 Firebase에서 감정 데이터 로드
        // common.js의 loadFromFirestore 함수를 사용합니다.
        // 이 함수는 common.js의 currentUser 변수에 의존합니다.
        // DOMContentLoaded 시점에 common.js의 setupAuth가 실행되어 currentUser가 설정됩니다.
        // 따라서 loadEmotionData는 DOMContentLoaded 이후에 호출되어야 합니다.
        // 현재 코드는 DOMContentLoaded에서 loadEmotionData를 호출하므로 순서는 맞습니다.
        // common.js의 loadFromFirestore 함수가 currentUser를 기다리도록 이미 구현되어 있습니다.
        // 따라서 별도의 변경 없이도 로그인 상태에 따라 Firebase 로드가 동작합니다.
        // 다만, 비동기 로드 완료 시점과 renderCalendar/updateStats 호출 시점의 동기화가 중요합니다.
        // 현재 DOMContentLoaded에서 await loadEmotionData()를 하지 않고 바로 renderCalendar() 등을 호출하고 있습니다.
        // Firebase 로드가 완료되기 전에 renderCalendar/updateStats가 실행될 수 있습니다.
        // 이를 개선하려면 loadEmotionData를 async로 만들고 await 해야 합니다.
        
        // 기존 loadEmotionData 함수 (로컬 스토리지 우선 로드)
        async function loadEmotionData() { // async 키워드 추가
            console.log("감정 데이터 로드 시작...");
            // 로컬 스토리지에서 로드
            const localData = loadFromLocalStorage('emotionData');
            if (localData) {
                emotionData = localData;
                console.log("로컬 스토리지에서 감정 데이터 로드 완료.");
            }
            
            // Firebase에서 로드 (로그인된 경우)
            // common.js의 loadFromFirestore는 단일 문서 로드용입니다.
            // 여기서는 컬렉션 전체를 로드해야 하므로 common.js의 loadFromFirestore를 직접 사용하기 어렵습니다.
            // 컬렉션 로드 로직을 여기에 직접 구현하거나 common.js에 컬렉션 로드 헬퍼 함수를 추가해야 합니다.
            // 현재 코드는 common.js의 loadFromFirestore를 사용하지 않고 직접 Firebase 컬렉션을 쿼리하고 있습니다.
            // 이 로직은 currentUser가 설정된 후에 실행되어야 합니다.
            // DOMContentLoaded에서 setupAuth가 먼저 실행되므로 대부분의 경우 currentUser가 설정됩니다.
            // 하지만 비동기적인 특성상 완벽한 보장을 위해 onAuthStateChanged 내에서 로드하는 것이 더 안전할 수 있습니다.
            // 현재 구조에서는 loadEmotionData 함수 자체를 async로 만들고,
            // DOMContentLoaded에서 await loadEmotionData()를 호출하는 것이 가장 간단한 개선 방법입니다.

            // 현재 코드는 common.js의 currentUser를 사용하고 있으므로,
            // common.js의 setupAuth가 완료된 후에 이 로직이 실행되도록 보장하는 것이 좋습니다.
            // DOMContentLoaded에서 setupAuth를 호출하고, setupAuth 내에서 onAuthStateChanged 콜백이 실행됩니다.
            // onAuthStateChanged 콜백 내에서 loadEmotionData를 호출하는 것이 가장 안전합니다.
            // 하지만 현재 구조를 크게 바꾸지 않으려면, loadEmotionData 함수 내에서 currentUser를 기다리는 로직을 추가하거나,
            // DOMContentLoaded에서 loadEmotionData 호출 전에 약간의 지연을 주거나 (권장하지 않음),
            // 또는 DOMContentLoaded에서 loadEmotionData를 async로 호출하고 await 하는 방법이 있습니다.
            
            // 현재 코드 구조를 유지하면서 개선하는 방법:
            // loadEmotionData 함수를 async로 만들고, DOMContentLoaded에서 await 합니다.
            // 또는 onAuthStateChanged 내에서 loadEmotionData를 호출합니다. (더 권장)
            
            // 현재 코드 (DOMContentLoaded에서 호출, async 아님)
            // async function loadEmotionData() { ... } 로 변경하고
            // DOMContentLoaded에서 await loadEmotionData(); 로 변경하는 것이 좋습니다.
            
            // 임시 방편으로, currentUser가 설정될 때까지 기다리는 간단한 로직 추가 (완벽하지 않음)
            // 또는 common.js의 setupAuth 함수 내 onAuthStateChanged 콜백에서 loadEmotionData() 호출
            
            // 현재 코드 구조를 유지하며 Firebase 로드 로직만 async/await 적용
            if (currentUser) {
                console.log("Firebase에서 감정 데이터 로드 시도...");
                try {
                    // Firestore에서 해당 사용자의 모든 감정 기록 로드
                    const snapshot = await db.collection('emotions')
                        .where('userId', '==', currentUser.uid)
                        .get();
                    
                    const firebaseData = {};
                    snapshot.forEach(doc => {
                        firebaseData[doc.id] = doc.data();
                    });
                    
                    // 로컬 데이터와 Firebase 데이터 병합 (Firebase 데이터 우선)
                    emotionData = { ...localData, ...firebaseData };
                    
                    saveToLocalStorage('emotionData', emotionData); // 병합된 데이터 로컬에 저장
                    console.log("Firebase에서 감정 데이터 로드 및 병합 완료.");
                } catch (error) {
                    console.error('Firebase 감정 데이터 로드 실패:', error);
                    // 실패 시 로컬 데이터만 사용
                }
            }
            console.log("감정 데이터 로드 종료. 현재 데이터:", emotionData);
        }
        
        // DOMContentLoaded에서 loadEmotionData를 await 하도록 수정
        document.addEventListener('DOMContentLoaded', async function() { // async 추가
            console.log("DOM fully loaded. Initializing color-journal.");
            // common.js의 DOMContentLoaded가 먼저 실행되어 header/footer 로드 및 setupAuth 완료
            // setupAuth의 onAuthStateChanged 콜백에서 currentUser가 설정됩니다.
            
            await loadEmotionData(); // 데이터 로드가 완료될 때까지 기다림
            renderCalendar();
            updateStats();
            setupEmotionSelector();
            console.log("Color-journal initialization complete.");
        });

        // ... (나머지 함수들)

        // updatePrescription 함수 수정 부분 (위에서 이미 diff로 제공됨)
        // function updatePrescription(emotionCounts, total) { ... }

        // loadEmotionData 함수 수정 부분 (위에서 이미 diff로 제공됨)
        // async function loadEmotionData() { ... }

        // DOMContentLoaded 수정 부분 (위에서 이미 diff로 제공됨)
        // document.addEventListener('DOMContentLoaded', async function() { ... });

        // ... (나머지 함수들)

        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }
        
        function lightenHexColor(hex, factor) {
            if (!hex || typeof hex !== 'string' || hex.charAt(0) !== '#') return '#cccccc'; 
            
            let r = parseInt(hex.slice(1, 3), 16);
            let g = parseInt(hex.slice(3, 5), 16);
            let b = parseInt(hex.slice(5, 7), 16);

            r = Math.round(r + (255 - r) * factor);
            g = Math.round(g + (255 - g) * factor);
            b = Math.round(b + (255 - b) * factor);

            r = Math.min(255, Math.max(0, r));
            g = Math.min(255, Math.max(0, g));
            b = Math.min(255, Math.max(0, b));

            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        window.addEventListener('click', function(event) {
            const modal = document.getElementById('emotionModal');
            if (event.target === modal) {
                closeEmotionModal();
            }
        });
    </script>
    
    <style>
        .emotion-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .emotion-btn {
            background: white;
            border: 2px solid #e1e8ed;
            border-radius: 15px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        
        .emotion-btn:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }
        
        .emotion-btn.selected {
            border-color: #667eea;
            background: #f8f9ff;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }
        
        .emotion-btn i {
            font-size: 2rem;
            color: #667eea;
        }
        
        .emotion-btn span {
            font-weight: 500;
            color: #333;
        }
    </style>
</body>
</html>
                return;
            }
            
            let dominantEmotionType = 'calm'; // 기본값
            let maxCount = 0;
            for (const [type, count] of Object.entries(emotionCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    dominantEmotionType = type;
                }
            }
            
            document.getElementById('prescriptionText').textContent = 
                prescriptions[dominantEmotionType] || "오늘 하루도 평온하시길 바랍니다.";
        }
        
        async function loadEmotionData() {
            const localData = loadFromLocalStorage('emotionData');
            if (localData) {
                emotionData = localData;
            }
            
            if (currentUser) {
                try {
                    const snapshot = await db.collection('emotions')
                        .where('userId', '==', currentUser.uid)
                        .get();
                    
                    snapshot.forEach(doc => {
                        emotionData[doc.id] = doc.data();
                    });
                    
                    saveToLocalStorage('emotionData', emotionData);
                } catch (error) {
                    console.error('Firebase 로드 실패:', error);
                }
            }
        }
        
        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }
        
        function lightenHexColor(hex, factor) {
            if (!hex || typeof hex !== 'string' || hex.charAt(0) !== '#') return '#cccccc'; 
            
            let r = parseInt(hex.slice(1, 3), 16);
            let g = parseInt(hex.slice(3, 5), 16);
            let b = parseInt(hex.slice(5, 7), 16);

            r = Math.round(r + (255 - r) * factor);
            g = Math.round(g + (255 - g) * factor);
            b = Math.round(b + (255 - b) * factor);

            r = Math.min(255, Math.max(0, r));
            g = Math.min(255, Math.max(0, g));
            b = Math.min(255, Math.max(0, b));

            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        window.addEventListener('click', function(event) {
            const modal = document.getElementById('emotionModal');
            if (event.target === modal) {
                closeEmotionModal();
            }
        });
    </script>
    
    <style>
        .emotion-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .emotion-btn {
            background: white;
            border: 2px solid #e1e8ed;
            border-radius: 15px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        
        .emotion-btn:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }
        
        .emotion-btn.selected {
            border-color: #667eea;
            background: #f8f9ff;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }
        
        .emotion-btn i {
            font-size: 2rem;
            color: #667eea;
        }
        
        .emotion-btn span {
            font-weight: 500;
            color: #333;
        }
    </style>
</body>
</html>
